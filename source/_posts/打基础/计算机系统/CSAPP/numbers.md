# 计算机的设计理念

> 在某大厂搬砖两年多，有逐渐成为没有灵魂代码机器的趋势。而且可能是应用层呆久了，总觉得对一些平时摸不到的底层缺乏了解。大学不算编程科班出身，一些基础课程基本也是划水 + 突击飘过，对于计算机这个专业的基础知识结构还是欠缺的，所以准备慢慢把之前欠的债还回来。考虑到自己三分钟热度，决定开一个正经的系列来建立自己对计算机系统的认知体系！主要参考书目就是经典中的经典：CSAPP 《深入理解计算机系统》了，文章不会过于纠结于细节，而是站在感受计算机系统设计的角度。


## 1. 问题提出
系列第一篇，主要目的是，搞清楚计算作为最基础功能，计算机是如何实现的？

回想我们在学习数学时，先学了有哪些数字，然后才接触了一些数字的运算。按照我们现有的知识，数字是无法穷尽的，那么在计算机的世界里，该怎么用有限的东西表示无穷的数字呢？能够用计算机表示数字之后，又怎样来实现一些基础的运算呢？

希望可以通过这篇文章，从设计角度探索下面几个问题：
+ 计算机中数字的表示？
+ 不同范围的数据之间是否可以相互转换？
+ 如何进行运算？

## 2. 探索过程
带着这两个问题，找了一些资料，看了一些书，也有了一些自己的理解，接下来简单描述一下过程。

### 2.1 二进制与进制转换

计算机存储和处理信息都是以二进制来表示，之所以用二进制是因为更容易通过穿孔卡片、导线上的高低电压等具有 2 种状态的物体或过程来表示。这样在很多介质中的数据传输等，就天然统一了，无需额外做编码或转换。
二进制的一位，只有 0 或 1 两种取值，每一位是一个 bit。对于需要表示的其他数字，如 26，只需增加二进制位数，即 11010。这里有一个十进制到二进制的转换方式，即除 2 倒取余。同样，对于一个二进制，也可以方便地转换为十进制，从高位到底位依次按权值展开相加即可。

<div  align="center">    
    <img src="../../../imgs/csapp_1.png" width = "400" height = "300" alt="examples" align=center />
</div>


由于二进制在书写和辨识等方面存在一些不便，过于冗长，人们就把 4 个二进制位用一个字母来表示，也就有了十六进制（0-9A-F），通常以 0x 开头。不足 4 位，前面补 0，即可完成转换。对于十六进制和十进制之间的转换，与二进制类似，在此不再赘述。


### 2.2 整数表示和运算

整数表示主要包括两部分，第一种是正数和 0（无符号整数），第二种是正数、负数和 0（有符号整数）。其中关键区别是对于符号位的特殊处理。
无符号整数的表示，直接利用二进制与十进制的转换方式即可实现。对于 8 位无符号整数，其可表示的范围是 0 - 255。
有符号整数的表示，则需要借助补码来表示，最高位作为符号位，0 为整数，1 为负数。对于 8 位有符号整数，可表示的范围是 -128 - 127。


<div  align="center">    
    <img src="../../../imgs/csapp_2.png" width = "400" height = "300" alt="examples" align=center />
</div>

对于补码到无符号数的映射关系，以 8 位为例，[0, 127] 的部分保持不变，补码的 [-128, -1] 会和无符号数的 [128, 255] 一一对应。
无符号数和有符号数之间的相互转换原则是，底层数据位不变，解析规则改变。


<div  align="center">    
    <img src="../../../imgs/csapp_3.png" width = "400" height = "300" alt="examples" align=center />
</div>


无符号整数加法：求和 + 取模
有符号整数加法：求和 + 取模（需判断方向，是正溢出还是负溢出）
无符号整数乘法：求乘积 + 取模
有符号整数乘法：求乘积 + 取模
由于乘法的运算会耗费更多的时钟周期，因此计算机中一般对乘法的处理是考虑通过移位和加法来实现。对于乘以常数的场景亦是如此。
除法的运算会消耗比乘法更多的时钟周期，也需通过移位来实现加速运算。

总结：
整数运算实际上是一种模运算形式。有限字长限制了可能的取值范围，导致结果可能溢出。
运算的过程大多通过位级运算来实现。

### 2.3 浮点数的表示和运算
遵循 IEEE 754 标准，将一个浮点数分为以下 3 个部分来表示：
符号：决定是正负数，1 -> 负数，0 -> 正数
阶码【移码】：对浮点数加权，若全为 1，则表示正无穷或负无穷（取决于符号位）；若全为 0，则表示机器 0
尾数【原码】：二进制小数，规格化后小数部分（1.0101010 -> 0101010），隐藏前置 1


<div  align="center">    
    <img src="../../../imgs/csapp_4.png" width = "400" height = "300" alt="examples" align=center />
</div>

阶码使用移码的意义：将数据映射到正数域，便于比较真值。
比较大小：符号位 -> 阶码 -> 尾数
浮点运算规则：对阶 -> 尾数运算 -> 规格化 -> 舍入处理 -> 溢出判断


总结：
IEEE 754 标准有点像一种二进制的科学计数法。
在位设计原则方面，确定位可考虑隐藏掉以提高精度。

## 3. 总结

对于将一个无界的问题转化成有限问题，一个很重要的点在于边界，把最通用的场景给覆盖到了，那么对于一些无穷的场景只需给出一个确定性的表现，使得系统行为可预知。

对于可能存在多种表示形式的数据，可通过规格化使其表示形式唯一，然后基于表示形式完成进一步操作，此时可简化后续步骤。

单纯考虑数据的表示有很多种形式，且无法看出明显优劣。但如果把场景放大，可能的扩展范围可考虑到，比如硬件 / 传输等，就会有新的答案和感知。当面临无法选择的境地时，可通过仔细思考是否有遗漏场景或考虑未来发展可能性来做决策。
